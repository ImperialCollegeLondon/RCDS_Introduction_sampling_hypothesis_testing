---
title: "Single Cell RNASeq analysis - mm10 Fitc negative cells WT and MT"
author: "LMS Bioinformatics: Jesus Urtasun; Jesus.Urtasun@lms.mrc.ac.uk"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  rmdformats::robobook:
    self_contained: true
    code_folding: hide
    thumbnails: false
    lightbox: true
    gallery: false
    highlight: tango
    number_sections: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}

# knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE, echo = T, message = FALSE, cache.lazy = FALSE)

```

# Project background

In this project Postdoc Teresa Perera aims to study the effect of the Stag2 mutation in the hematopoietic function and 3D genome organization. Recent studies show that a KO of the Stag2 gene leads to enhanced self-renewal properties in hematopoietic STEM cells. The dataset used in this experiment is formed by a wild-type population (WT), and a mutant one (MT), in which the Stag2 gene has not been directly knocked out, but rather mutated with CRISPR, such that the cohesin complex can extrude DNA loops but interactions with its ligands - such as CTCF - might be affected. The cohesin complex will be formed and extruding DNA loops, but - presumably - it will not bind to the CTCF binding protein that stops the looping.

This dataset is composed only by female mice samples, with mutant Fitc positive STEM cells (ID from genomics: NS2K TPSa2R)

# Data Source

* Rawdata in Imperial HPC
  
      /rds/general/project/lms-merkenshlager-raw/live/230720_VH00504_139_AAAYCYFHV_custom_genome

* Analysis folder in Network Drive
  
      /Volumes/bioinfomatics$/jurtasun/Projects/Lymphocyte_Development/PI_Merkenschlager_Matthias/Perera_Teresa/scRNASeq_NS2K_TPSa2R_custom_genome
      
* There are 2 directories under /rds/general/project/lms-merkenshlager-raw/live/230720_VH00504_139_AAAYCYFHV

  + Unaligned – contains output of CellRanger mkfastq pipeline (v5.0.1). 
        
      + Fastq files: R1 contains cell barcodes and UMI sequences
      + R2 contains cDNA sequences.

  + Processed - contains output of CellRanger count pipeline. This pipeline identifies cell barcodes, counts UMIs and produces gene-barcode matrix.
  
      + outs/ directory contains the summary HTML file (attached here), gene-barcode matrices, barcoded BAMs, and molecule info. More information: https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/output/overview

      + This HTML contains summary metrics and secondary analysis results. More information: https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/output/summary

* This pipeline generates 2 matrices

     + Raw gene-barcode matrices (outs/ raw_feature_bc_matrix/: Contains every barcode from fixed list of known-good barcode sequences. This includes background and non-cellular barcodes.
          
     + Filtered gene-barcode matrices (outs/ filtered_feature_bc_matrix/): Contains only detected cellular barcodes.

* Each directory contains 3 files : barcodes.tsv, genes.tsv and matrix.mtx
      
* Information on how to load the data in to R or in Python cab be found here:
https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/output/matrices

* An overview of the algorithms used in CellRanger is available here:
https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/algorithms/overview

* QC summary from cellranger pipeline can be downloaded from here:
[[https://imperiallondon-my.sharepoint.com/:f:/g/personal/jurtasun_ic_ac_uk/EkY_B4SBQA1FmrDvZmOldCoB8oNWOBPLOFf_03SDCM7CXQ?e=Fzhwk8]]
    
* This report `"scRNASeq_NS2K_TPSa2R_filtered.html"`, can be retrieved from here:
[[https://imperiallondon-my.sharepoint.com/:f:/g/personal/jurtasun_ic_ac_uk/EgfDne6E6SxAkA6jfSHexYgBDH4uNYJo7SBASjicts5vJw?e=V1CVlV]] 

# Data preprocessing

* Data was de-multiplexed and analysed using CellRanger v5.0.1 and bcl2fastq v2.20.0.

* Libraries were de-multiplexed with CellRanger mkfastq based on the sample indices (allowing 0 mismatches)

* CellRanger count pipeline was used to perform alignment against mouse genome mm10 (using STAR), filtering and counting UMIs.

* Seurat (Seurat_4.1.0; Hao et al., 2021; Butler et al., 2018; Stuart et al., 2019) was applied for scRNAseq analysis.

* Reference:

      + Hao Y, Hao S, Andersen-Nissen E, et al. (2021). Integrated analysis of multimodal single-cell data. Cell. 2021 Jun 24; 184(13):3573-3587.e29. doi: 10.1016/j.cell.2021.04.048.

      + Stuart T, Butler A, Hoffman P, et al. (2019). Comprehensive Integration of Single-Cell Data. Cell. 177(7):1888-1902.e21.

      + Butler A, Hoffman P, Satija R, et al. (2018). Integrating single-cell transcriptomic data across different conditions, technologies, and species. Nat Biotechnol. 36(5):411-420.

```{r import, cache = T, echo = T, eval = T, warnings = F, messages = F}

# Import libraries

# General R and Seurat
suppressPackageStartupMessages(library(Seurat))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(gridExtra))
suppressPackageStartupMessages(library(e1071))
suppressPackageStartupMessages(library(cowplot))
suppressPackageStartupMessages(library(multtest))
suppressPackageStartupMessages(library(metap))
suppressPackageStartupMessages(library(tidyr))


# Cluster annotation
# Installing ScType from github
# https://github.com/IanevskiAleksandr/sc-type/blob/master/README.md
# source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R");
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R")
suppressPackageStartupMessages(library(HGNChelper))
suppressPackageStartupMessages(library(igraph))
suppressPackageStartupMessages(library(ggraph))
suppressPackageStartupMessages(library(readxl))
suppressPackageStartupMessages(library(DESeq2))

# GO
suppressPackageStartupMessages(library(org.Hs.eg.db))
suppressPackageStartupMessages(library(org.Mm.eg.db))
suppressPackageStartupMessages(library(biomaRt))
suppressPackageStartupMessages(library(msigdbr))
suppressPackageStartupMessages(library(DOSE))

# Set working directory
workdir <- "/Volumes/bioinfomatics$/jurtasun/Projects/Lymphocyte_Development/PI_Merkenschlager_Matthias/Perera_Teresa/scRNASeq_NS2K_TPSa2R_filtered/Analysis"
setwd(workdir)

```


## Load count data

* Use as input the cellranger filtered counts and cells.

* The following parameters are used:

    + min.cells = 1 (Include features, i.e. genes, detected in at least this many cells)

    + min.features = 100 (Include cells where at least this many features, i.e. genes, are detected)

```{r count, cache = T, echo = T, eval = T, warnings = F, messages = F}

# # Read WT and MT single cell data
# WT_data <- Read10X(data.dir = "../Rawdata/TP2_SA2R_wildtype/filtered_feature_bc_matrix/")
# MT_data <- Read10X(data.dir = "../Rawdata/TP1_SA2R_mutant/filtered_feature_bc_matrix/")
# save(WT_data, file = "Seurat_Object/WT_data.RData")
# save(MT_data, file = "Seurat_Object/MT_data.RData")
# 
# # Create Seurat object for WT and MT data
# WT_SO <- CreateSeuratObject(counts = WT_data, min.cells = 1, min.features = 100, project = "WT")
# MT_SO <- CreateSeuratObject(counts = MT_data, min.cells = 1, min.features = 100, project = "MT")
# save(WT_SO, file = "Seurat_Object/WT_SO.RData")
# save(MT_SO, file = "Seurat_Object/MT_SO.RData")
# 
# # Check the dimensions of the WT and MT data
# dim(WT_data)
# dim(WT_SO)
# dim(MT_data)
# dim(MT_SO)

# Load WT and MT data
load("Seurat_Object/WT_data.RData")
load("Seurat_Object/WT_SO.RData")
load("Seurat_Object/MT_data.RData")
load("Seurat_Object/MT_SO.RData")

# # Look for LacZ
# tail(rownames(WT_data)); sum(WT_data["LacZ", ])
# tail(rownames(MT_data)); sum(MT_data["LacZ", ])

```

## Quality Control & selecting cells for downstream analysis

* Filtering raw data helps removing most doublets / dead cells/ / mpty droplets, hence why filtering is a common pre-processing step in any SC analysis. The QC metrics used here are the ones typically used by the sc community, such as `nFeature_RNA`, `nCount_RNA`, `pt.mitochondria`:

* Reference:

      + Ilicic T, Kim JK, Teichmann SA, et al. (2016). Classification of low quality cells from single-cell RNA-seq data. Genome Biol. 17:29.)

* 1. The number of unique genes detected in each cell (`nFeature_RNA`):

     + Low-quality cells (dead / dying) or empty droplets will often have very few genes
     
     + Low nFeature_RNA for a cell sometimes indicates that it may be dead/dying; Cell doublets or multiplets may exhibit an aberrantly high gene count

* 2. The total number of molecules detected within a cell (`nCount_RNA`). Named `nUMI` before Seurat V3:

     + Total number of moelules, nCount_RNA`, correlates strongly with unique genes
     
     + High nCount_RNA and/or nFeature_RNA indicates that the "cell" may in fact be a doublet (or multiplet)

* 3. The percentage of reads that map to the mitochondrial genome.

     + We use the `PercentageFeatureSet()` function to which compute percentage of counts originating from a given set of features (mitochondrial, ribosomal, etc):

     + Low-quality / dying cells often exhibit extensive mitochondrial contamination

     + We use the set of all genes starting with `mt-` as a set of mitochondrial genes

## QC metrics {.tabset}

### Wild-type

```{r QC1_wt, cache = T, echo = T, eval = T, warnings = F, messages = F, fig.height = 4.5}

# Get percentage of mitochondrial / ribosomal DNA
WT_SO[["percent_mt"]] <- PercentageFeatureSet(WT_SO, pattern = "^mt")
WT_SO[["percent_rb"]] <- PercentageFeatureSet(WT_SO, pattern = "^Rp[ls]")

# # Subset the wild-type data
# WT_SO_filtered <- subset(WT_SO, subset = nCount_RNA >= 10000 & nCount_RNA <= 1000000 &
#                                      nFeature_RNA >= 1000 & nFeature_RNA <= 7500 &
#                                      percent_mt >= 1 & percent_mt <= 7.5)
# save(WT_SO_filtered, file = "Seurat_Object/WT_SO_filtered.RData")
load("Seurat_Object/WT_SO_filtered.RData")
WT_SO_filtered[["percent_rb"]] <- PercentageFeatureSet(WT_SO, pattern = "^Rp[ls]")

# Visualize the QC metrics
VlnPlot(WT_SO, features = c("nCount_RNA", "nFeature_RNA", "percent_mt", "percent_rb"), ncol = 4)
# pdf(paste0(workdir, "/../QC_10X/violin_wt_raw.pdf"), width = 10, height = 10)
# VlnPlot(WT_SO, features = c("nCount_RNA", "nFeature_RNA", "percent_mt", "percent_rb"), ncol = 4)
# dev.off()
VlnPlot(WT_SO_filtered, features = c("nCount_RNA", "nFeature_RNA", "percent_mt", "percent_rb"), ncol = 4)
# pdf(paste0(workdir, "/../QC_10X/violin_wt_filtered.pdf"), width = 10, height = 10)
# VlnPlot(WT_SO_filtered, features = c("nCount_RNA", "nFeature_RNA", "percent_mt", "percent_rb"), ncol = 4)
# dev.off()

```

### Mutant

```{r QC1_mt, cache = T, echo = T, eval = T, warnings = F, messages = F, fig.height = 4.5}

# Get percentage of mitochondrial / ribosomal DNA
MT_SO[["percent_mt"]] <- PercentageFeatureSet(MT_SO, pattern = "^mt")
MT_SO[["percent_rb"]] <- PercentageFeatureSet(MT_SO, pattern = "^Rp[ls]")

# # Subset the mutant data
# MT_SO_filtered <- subset(MT_SO, subset = nCount_RNA >= 10000 & nCount_RNA <= 1000000 &
#                                      nFeature_RNA >= 1000 & nFeature_RNA <= 7500 &
#                                      percent_mt >= 1 & percent_mt <= 7.5)
# save(MT_SO_filtered, file = "Seurat_Object/MT_SO_filtered.RData")
load("Seurat_Object/MT_SO_filtered.RData")
MT_SO_filtered[["percent_rb"]] <- PercentageFeatureSet(MT_SO, pattern = "^Rp[ls]")

# Visualize the QC metrics
VlnPlot(MT_SO, features = c("nCount_RNA", "nFeature_RNA", "percent_mt", "percent_rb"), ncol = 4)
# pdf(paste0(workdir, "/../QC_10X/violin_mt_raw.pdf"), width = 10, height = 10)
# VlnPlot(MT_SO, features = c("nCount_RNA", "nFeature_RNA", "percent_mt", "percent_rb"), ncol = 4)
# dev.off()
VlnPlot(MT_SO_filtered, features = c("nCount_RNA", "nFeature_RNA", "percent_mt", "percent_rb"), ncol = 4)
# pdf(paste0(workdir, "/../QC_10X/violin_mt_filtered.pdf"), width = 10, height = 10)
# VlnPlot(MT_SO_filtered, features = c("nCount_RNA", "nFeature_RNA", "percent_mt", "percent_rb"), ncol = 4)
# dev.off()

```

## Number of cells after filtering QC metrics {.tabset}

### Wild-type

* Summary of the remaining number of cells after each filtering stage

```{r QC2_wt, cache = T, echo = T, eval = T, warnings = F, messages = F, fig.height = 4.5}

# Convert the plots to data frames and customize
WT_raw <- CreateSeuratObject(counts = WT_data, project = "WT")
WT_df_raw <- as.data.frame(WT_raw@meta.data)
WT_df_seurat <- as.data.frame(WT_SO@meta.data)
WT_df_filtered <- as.data.frame(WT_SO_filtered@meta.data)

# Bar plot comparing the number of cells after filtering
wt_cells_raw <- ncol(WT_raw)
wt_cells_seurat <- ncol(WT_SO)
wt_cells_filtered <- ncol(WT_SO_filtered)
cat("\nRaw data: ", dim(WT_raw)[2], " cells")
cat("\nAfter loading to Seurat: ", dim(WT_SO)[2], " cells")
cat("\nAfter filtering QC metrics: ", dim(WT_SO_filtered)[2], " cells")
# write.table(paste("\nRaw data: ", dim(WT_raw)[2], " cells",
#       "\nAfter loading to Seurat: ", dim(WT_SO)[2], " cells",
#       "\nAfter filtering QC metrics: ", dim(WT_SO_filtered)[2], " cells"),
#       file = paste(workdir, "/../QC_10X/summary_wt.txt", sep = ""))

# Save bar plot
barplot(c(wt_cells_raw, wt_cells_seurat, wt_cells_filtered), 
        names.arg = c("Raw data", "After Seurat", "After QC"), col = "blue", main = "Number of Cells")
pdf(paste(workdir, "/../QC_10X/barplot_wt.pdf", sep = ""), width = 10, height = 10)
# barplot(c(wt_cells_raw, wt_cells_seurat, wt_cells_filtered),
#         names.arg = c("Raw data", "After Seurat", "After QC"), col = "blue", main = "Number of Cells")
# dev.off()

```

### Mutant

* Summary of the remaining number of cells after each filtering stage
     
```{r QC2_mt, cache = T, echo = T, eval = T, warnings = F, messages = F, fig.height = 4.5}

# Convert the plots to data frames and customize
MT_raw <- CreateSeuratObject(counts = MT_data, project = "MT")
MT_df_raw <- as.data.frame(MT_raw@meta.data)
MT_df_seurat <- as.data.frame(MT_SO@meta.data)
MT_df_filtered <- as.data.frame(MT_SO_filtered@meta.data)

# Bar plot comparing the number of cells after filtering
mt_cells_raw <- ncol(MT_raw)
mt_cells_seurat <- ncol(MT_SO)
mt_cells_filtered <- ncol(MT_SO_filtered)
cat("\nRaw data: ", dim(MT_raw)[2], " cells")
cat("\nAfter loading to Seurat: ", dim(MT_SO)[2], " cells")
cat("\nAfter filtering QC metrics: ", dim(MT_SO_filtered)[2], " cells")
# write.table(paste("\nRaw data: ", dim(MT_raw)[2], " cells",
#       "\nAfter loading to Seurat: ", dim(MT_SO)[2], " cells",
#       "\nAfter filtering QC metrics: ", dim(MT_SO_filtered)[2], " cells"),
#       file = paste(workdir, "/../QC_10X/summary_mt.txt", sep = ""))

barplot(c(mt_cells_raw, mt_cells_seurat, mt_cells_filtered), 
        names.arg = c("Raw data", "After Seurat", "After QC"), col = "blue", main = "Number of Cells")
pdf(paste(workdir, "/../QC_10X/barplot_mt.pdf", sep = ""), width = 10, height = 10)
# barplot(c(wt_cells_raw, mt_cells_seurat, mt_cells_filtered),
#         names.arg = c("Raw data", "After Seurat", "After QC"), col = "blue", main = "Number of Cells")
# dev.off()

```

# Normalization and dimensional reduction

## Normalizing the data

* Once the unwanted / ill-identified cells have been removed from the dataset, the next step is to normalize the data.

* We use the `NormalizeData()` function with the default method “LogNormalize”, that normalizes the feature expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default), and log-transforms the result.

* Normalized values are stored in seurat_object[["RNA"]]@meta.data.

## Identification of highly variable features (feature selection)

* We next calculate the subset of features that exhibit high cell-to-cell variation in the dataset (i.e, they are highly expressed in some cells, and lowly expressed in others). The Seurat team and others (Brennecke et al., 2013) have found that focusing on these genes in downstream analysis helps to highlight biological signal in single-cell datasets.

* Details within Seurat are described in here (Stuart et al., 2019), and improves on previous versions by directly modeling the mean-variance relationship inherent in single-cell data. These are implemented in the `FindVariableFeatures()` function. These will be used in downstream analysis, like PCA.

* Reference:

      + Stuart T et al. (2019). Comprehensive Integration of Single-Cell Data. Cell. 177(7):1888-1902.e21.

      + Brennecke P et al. (2013) Accounting for technical noise in single-cell RNA-seq experiments. Nat Methods. 2013 Nov;10(11):1093-5. Erratum in: Nat Methods. 2014 Feb;11(2):210.

## Scaling the data

* Here we apply a linear transformation ("scaling") that is a standard pre-processing step prior to dimensional reduction techniques like PCA.

* The `ScaleData()` function:

  + Shifts the expression of each gene, so that the mean expression across cells is 0

  + Scales the expression of each gene, so that the variance across cells is 1

This step gives equal weight in downstream analyses, so that highly-expressed genes do not dominate.

```{r norm1, cache = T, echo = T, eval = T, warnings = F, messages = F, fig.height = 5, fig.width = 6}

# LogNormalize
WT_processed <- NormalizeData(WT_SO_filtered, normalization.method = "LogNormalize", scale.factor = 10000)
MT_processed <- NormalizeData(MT_SO_filtered, normalization.method = "LogNormalize", scale.factor = 10000)

# Find variable features (higly expressed in some cells, lowly express in others)
WT_processed <- FindVariableFeatures(WT_SO_filtered, selection.method = "vst", nfeatures = 2000)
MT_processed <- FindVariableFeatures(MT_SO_filtered, selection.method = "vst", nfeatures = 2000)

# Load gene sets for cell cycle scores
cc_s_genes_human <- cc.genes.updated.2019$s.genes
cc_g2m_genes_human <- cc.genes.updated.2019$g2m.genes
write.csv(cc_s_genes_human, paste0(workdir, "/cc_s_genes_human.csv"), row.names = F)
write.csv(cc_g2m_genes_human, paste0(workdir, "/cc_g2m_genes_human.csv"), row.names = F)

# Convert human mouse
# https://medium.com/@daimin0514/how-to-convert-human-gene-symbols-to-mouse-gene-symbols-ad52d68e82fd
cc_s_genes_mouse <- read.csv(paste0(workdir, "/cc_s_genes_mouse.csv"))
cc_g2m_genes_mouse <- read.csv(paste0(workdir, "/cc_g2m_genes_mouse.csv"))
cc_s_genes_mouse <- as.character(cc_s_genes_mouse$Mouse.gene.name); cc_s_genes_mouse <- cc_s_genes_mouse[cc_s_genes_mouse != ""]
cc_g2m_genes_mouse <- as.character(cc_g2m_genes_mouse$Mouse.gene.name); cc_g2m_genes_mouse <- cc_g2m_genes_mouse[cc_g2m_genes_mouse != ""]
all(cc_s_genes_mouse %in% rownames(WT_processed)); all(cc_g2m_genes_mouse %in% rownames(WT_processed))
all(cc_s_genes_mouse %in% rownames(MT_processed)); all(cc_g2m_genes_mouse %in% rownames(MT_processed))

# Compute cell cycle score
WT_processed <- CellCycleScoring(WT_processed, s.features = cc_s_genes_mouse, g2m.features = cc_g2m_genes_mouse, ctrl = )
MT_processed <- CellCycleScoring(MT_processed, s.features = cc_s_genes_mouse, g2m.features = cc_g2m_genes_mouse)
WT_processed@meta.data$CC_Diff <- WT_processed@meta.data$S.Score - WT_processed@meta.data$G2M.Score
MT_processed@meta.data$CC_Diff <- WT_processed@meta.data$S.Score - WT_processed@meta.data$G2M.Score

# Scale and store WT and MT processed
WT_processed <- ScaleData(WT_processed, features = rownames(WT_processed), vars.to.regress)
MT_processed <- ScaleData(MT_processed, features = rownames(MT_processed), vars.to.regress)

# Scale data - regressing out .........................................................................................

# Scale Data
WT_processed <- ScaleData(WT_processed, features = rownames(WT_processed), vars.to.regress = c("nCount_RNA", "nFeature_RNA", "percent_mt", "CC_Diff"))
MT_processed <- ScaleData(MT_processed, features = rownames(MT_processed), vars.to.regress = c("nCount_RNA", "nFeature_RNA", "percent_mt", "CC_Diff"))
WT_processed <- Store_Misc_Info_Seurat(
      WT_processed, data_to_store = c("nCount_RNA", "nFeature_RNA", "percent_mt", "CC_Diff"), data_name = "RNA_ScaleData_regressOut")
MT_processed <- Store_Misc_Info_Seurat(
      MT_processed, data_to_store = c("nCount_RNA", "nFeature_RNA", "percent_mt", "CC_Diff"), data_name = "RNA_ScaleData_regressOut")

# # Save top variable features
# wt_vf <- head(VariableFeatures(WT_processed), 200)
# mt_vf <- head(VariableFeatures(MT_processed), 200)
# write.table("Top variable genes: WT\n", file = paste(workdir, "/../QC_10X/variable_features_wt.txt", sep = ""))
# write.table(wt_vf, file = paste(workdir, "/../QC_10X/variable_features_wt.txt", sep = ""), append = TRUE)
# write.table("Top variable genes: MT\n", file = paste(workdir, "/../QC_10X/variable_features_mt.txt", sep = ""))
# write.table(mt_vf, file = paste(workdir, "/../QC_10X/variable_features_mt.txt", sep = ""), append = TRUE)

# # Identify the 10 most highly variable genes
# WT_top10 <- head(VariableFeatures(WT_processed), 10)
# MT_top10 <- head(VariableFeatures(MT_processed), 10)
#
# # Plot variable features
# cat("\n###Wild-type")
# LabelPoints(plot = VariableFeaturePlot(WT_processed), points = WT_top10, repel = TRUE)
# cat("\n")
# cat("\n###Mutant")
# LabelPoints(plot = VariableFeaturePlot(MT_processed), points = MT_top10, repel = TRUE)
# # cat("\n")

```

## Linear dimensional reduction

* Next we perform PCA on the scaled data.`DimHeatmap()` allows for easy exploration of the primary sources of heterogeneity in a dataset, and can be useful when trying to decide which PCs to include for further downstream analyses.

* Both cells and features are ordered according to their PCA scores

     + Setting cells to a specific value plots the ‘extreme’ cells on both ends of the spectrum, which speeds plotting for large datasets.

     + Though a supervised analysis, we find this to be a valuable tool for exploring correlated feature sets.

## Determine ‘dimensionality’ of the dataset {.tabset}

* We use an ‘Elbow plot’ to rank the principal components based on the percentage of variance explained by each one (`ElbowPlot()` function).

* In this example, we can observe an ‘elbow’ around PC15, suggesting that the majority of true signal is captured in the first 15 PCs.

* Identifying the true dimensionality of a dataset can be a challenging / uncertain for the user. We therefore suggest three approaches to consider:

     + Tirst is more supervised, exploring PCs to determine relevant sources of heterogeneity, and could be used in conjunction with GSEA for example

     + Second implements a statistical test based on a random null model, but is time-consuming for large datasets, and may not return a clear PC cutoff

     + Third is a heuristic algorithm that is commonly used, and can be calculated instantly

### Wild-type

```{r pca1, cache = T, echo = T, eval = T, warnings = F, messages = F, fig.height = 5, fig.width = 6}

# # PCA on scaled data
# WT_processed <- RunPCA(WT_processed, features = VariableFeatures(object = WT_processed))
# save(WT_processed, file = "Seurat_Object/WT_processed.RData")
load("Seurat_Object/WT_processed.RData")

# Examine and visualize PCA results a few different ways
print(WT_processed[["pca"]], dims = 1:5, nfeatures = 5)

# Check genes that visualize the principal components
# VizDimLoadings(WT_processed, dims = 1:2, reduction = "pca")

# Plot PCs and Elbow plot
DimHeatmap(WT_processed, dims = 1:6, cells = 500, balanced = TRUE)
ElbowPlot(WT_processed)
# pdf(paste(workdir, "/Heatmaps/PCAs123_wt.pdf", sep = ""), width = 10, height = 10)
# DimHeatmap(WT_processed, dims = 1:3, cells = 500, balanced = TRUE)
# dev.off()
# pdf(paste(workdir, "/Heatmaps/PCAs456_wt.pdf", sep = ""), width = 10, height = 10)
# DimHeatmap(WT_processed, dims = 4:6, cells = 500, balanced = TRUE)
# dev.off()

```

### Mutant

```{r pca2, cache = T, echo = T, eval = T, warnings = F, messages = F, fig.height = 5, fig.width = 6}

# # PCA on scaled data
# MT_processed <- RunPCA(MT_processed, features = VariableFeatures(object = MT_processed))
# save(MT_processed, file = "Seurat_Object/MT_processed.RData")
load("Seurat_Object/MT_processed.RData")

# Examine and visualize PCA results a few different ways
print(MT_processed[["pca"]], dims = 1:5, nfeatures = 5)

# # Check genes that visualize the principal components
# VizDimLoadings(MT_processed, dims = 1:2, reduction = "pca")

# Plot PCs and Elbow plot
DimHeatmap(MT_processed, dims = 1:6, cells = 500, balanced = TRUE)
ElbowPlot(MT_processed)
# pdf(paste(workdir, "/Heatmaps/PCAs123_mt.pdf", sep = ""), width = 10, height = 10)
# DimHeatmap(MT_processed, dims = 1:3, cells = 500, balanced = TRUE)
# dev.off()
# pdf(paste(workdir, "/Heatmaps/PCAs456_mt.pdf", sep = ""), width = 10, height = 10)
# DimHeatmap(MT_processed, dims = 4:6, cells = 500, balanced = TRUE)
# dev.off()

```

# Non-linear dimensional reduction (UMAP)

* Once the dataset is normalized and variable fatures have been selected, we can proceed to cluster projection. The most comonly used clustering methods in SC are the so-called Uniform Manifold Approximation and Projection for Dimensional Reduction (UMAP) and t-distributed Stochastic Neighbor Embedding (t-SNE)

* Reference

      + McInnes, L, Healy, J (2018) UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction, ArXiv e-prints 1802.03426

      + van der Maaten, Laurens & Hinton, Geoffrey (2008) Viualizing data using t-SNE. Journal of Machine Learning Research. 9. 2579-2605

* Seurat v3 applies a graph-based clustering approach, building upon initial strategies in (Macosko et al). Importantly, the distance metric which drives the clustering analysis (based on previously identified PCs) remains the same. However, our approach to partitioning the cellular distance matrix into clusters has dramatically improved.

* Our approach was inspired by recent manuscripts which applied graph-based clustering approaches to scRNA-seq data [`SNN-Cliq, Xu and Su, Bioinformatics, 2015`] and CyTOF data [`PhenoGraph, Levine et al., Cell, 2015`]. Briefly, these methods embed cells in a graph structure - such as a K-nearest neighbor (KNN) graph - with edges drawn between cells with similar feature expression patterns, and then attempt to partition this graph into highly interconnected ‘quasi-cliques’ or ‘communities’.

* As in PhenoGraph, we first construct a KNN graph based on the euclidean distance in PCA space, and refine the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard similarity). This step is performed using the `FindNeighbors()` function, and takes as input the previously defined dimensionality of the dataset (first 10 PCs).

* To cluster the cells, we next apply modularity optimization techniques such as the Louvain algorithm (default) or SLM [`SLM, Blondel et al., Journal of Statistical Mechanics`], to interatively group cells together, with the goal of optimizing the standard modularity function. The `FindClusters()` function implements this procedure, and contains a resolution parameter that sets the ‘granularity’ of the downstream clustering, with increased values leading to a greater number of clusters. We find that setting this parameter between 0.4-1.2 typically returns good results for single-cell datasets of around 3K cells. Optimal resolution often increases for larger datasets. The clusters can be found using the `Idents()` function.

## UMAP clustering {.tabset}

* Figures in high resolution can be found here
[[https://imperiallondon-my.sharepoint.com/:f:/g/personal/jurtasun_ic_ac_uk/EgfDne6E6SxAkA6jfSHexYgBDH4uNYJo7SBASjicts5vJw?e=XJv0ys]]

### Wild-type

```{r umap_wt, cache = T, echo = T, eval = T, warnings = F, messages = F, fig.height = 5, fig.width = 8}

# # Compute UMAP
# WT_processed <- FindNeighbors(WT_processed, dims = 1:10)
# WT_processed <- FindClusters(WT_processed, resolution = 0.4)
# WT_processed <- RunUMAP(WT_processed, dims = 1:10)
# save(WT_processed, file = "Seurat_Object/WT_processed.RData")
load("Seurat_Object/WT_processed.RData")

# Plot UMAP
DimPlot(WT_processed, reduction = "umap")
# pdf(paste(workdir, "/UMAPs/wt_umap_vars_to_regress.pdf", sep = ""), width = 10, height = 10)
# DimPlot(WT_processed, reduction = "umap")
# dev.off()

# Find markers for every cluster compared to all remaining cells, report only the positive ones
# WT_markers <- FindAllMarkers(WT_processed, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
# WT_markers %>% group_by(cluster) %>% slice_max(n = 2, order_by = avg_log2FC)
# write.csv(WT_markers, file = "Cell_Markers/wt_markers.csv", row.names = F)

# # Look for specific genes
# grep("LacZ", rownames(WT_processed@assays$RNA@scale.data))
# FeaturePlot(WT_processed, features = c("LacZ"))
# DimPlot(WT_processed, reduction = "umap", group.by = "is_LacZ")
# WT_processed@meta.data$is_LacZ <- WT_processed@assays$RNA@counts["LacZ", ] > 0
# pdf(paste(workdir, "/UMAPs/wt_LacZ.pdf", sep = ""), width = 10, height = 10)
# FeaturePlot(WT_processed, features = c("LacZ"))
# dev.off()

# Check QC metrics
FeaturePlot(WT_processed, features = c("nFeature_RNA", "nCount_RNA", "percent_mt", "percent_rb"))
# pdf(paste(workdir, "/UMAPs/wt_umap_QC.pdf", sep = ""), width = 10, height = 10)
# FeaturePlot(WT_processed, features = c("nFeature_RNA", "nCount_RNA", "percent_mt", "percent_rb"))
# dev.off()

```

### Mutant

```{r umap_mt, cache = T, echo = T, eval = T, warnings = F, messages = F, fig.height = 5, fig.width = 8}

# # Compute UMAP
# MT_processed <- FindNeighbors(MT_processed, dims = 1:10)
# MT_processed <- FindClusters(MT_processed, resolution = 0.4)
# MT_processed <- RunUMAP(MT_processed, dims = 1:10)
# save(MT_processed, file = "Seurat_Object/MT_processed.RData")
load("Seurat_Object/MT_processed.RData")

# Plot UMAP
DimPlot(MT_processed, reduction = "umap")
# pdf(paste(workdir, "/UMAPs/mt_umap_vars_to_regress.pdf", sep = ""), width = 10, height = 10)
# DimPlot(MT_processed, reduction = "umap")
# dev.off()

# Find markers for every cluster compared to all remaining cells, report only the positive ones
# MT_markers <- FindAllMarkers(MT_processed, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
# MT_markers %>% group_by(cluster) %>% slice_max(n = 2, order_by = avg_log2FC)
# write.csv(MT_markers, file = "Cell_Markers/mt_markers.csv", row.names = F)

# Look for specific genes
# grep("LacZ", rownames(MT_processed@assays$RNA@scale.data))
# FeaturePlot(MT_processed, features = c("LacZ"))
# MT_processed@meta.data$is_LacZ <- MT_processed@assays$RNA@counts["LacZ", ] > 0
# DimPlot(MT_processed, reduction = "umap", group.by = "is_LacZ")
# pdf(paste(workdir, "/UMAPs/mt_LacZ.pdf", sep = ""), width = 10, height = 10)
# FeaturePlot(MT_processed, features = c("LacZ"))
# dev.off()

# Check QC metrics
FeaturePlot(MT_processed, features = c("nFeature_RNA", "nCount_RNA", "percent_mt", "percent_rb"))
# pdf(paste(workdir, "/UMAPs/mt_umap_QC.pdf", sep = ""), width = 10, height = 10)
# FeaturePlot(MT_processed, features = c("nFeature_RNA", "nCount_RNA", "percent_mt", "percent_rb"))
# dev.off()

```

# Data integration

* Integration is required to account for the batch effect correction. In this example we use the `FindIntegrationAnchors()` and `IntegrateData()`

* Reference

      + Stuart et al., Comprehensive Integration of Single Cell data, Cell 177, 1888–1902 (2019)

      + Haghverdi, Lun, Morgan, Marioni, Batch effects in single-cell RNA-sequencing data are corrected by matching mutual nearest neighbors, Nature Biotechnology 36 421–427 (2018)

## Integration of WT and MT datasets

* Ideally, cells coming from different groups / sample sets should overlap.

* Clusters should be homogeneously distributed across samples sets.

```{r integration1, cache = T, echo = T, eval = T, warnings = F, messages = F, fig.height = 8, fig.width = 12, results = "asis"}

# # Prepare a list of Seurat objects
# load("Seurat_Object/WT_processed.RData")
# load("Seurat_Object/MT_processed.RData")
# object_list <- list(WT_processed, MT_processed)
# 
# # Integrate data - Integration anchors with Canonical Correlation Analysis (CCA)
# features <- SelectIntegrationFeatures(object.list = object_list)
# anchors <- FindIntegrationAnchors(object.list = object_list, anchor.features = features)
# seurat_integrated <- IntegrateData(anchorset = anchors)
# 
# # Scale data
# seurat_integrated <- NormalizeData(seurat_integrated, normalization.method = "LogNormalize", scale.factor = 10000)
# seurat_integrated <-  ScaleData(object = seurat_integrated)
# seurat_integrated <-  RunPCA(object = seurat_integrated)
# seurat_integrated <-  RunUMAP(object = seurat_integrated, dims = 1:15)
# save(seurat_integrated, file = "Seurat_Object/seurat_integrated.RData")
load("Seurat_Object/seurat_integrated.RData")

# Plot integrated UMAP - by sample
DimPlot(seurat_integrated, reduction = "umap", group.by = "orig.ident")
# pdf(paste(workdir, "/Umaps/integrated_umap_sample.pdf", sep = ""), width = 10, height = 10)
# DimPlot(seurat_integrated, reduction = "umap", group.by = "orig.ident")
# dev.off()

# Plot integrated UMAP - by clusters
DimPlot(seurat_integrated, reduction = "umap", group.by = "seurat_clusters")
# pdf(paste(workdir, "/UMAPs/integrated_umap_clusters.pdf", sep = ""), width = 10, height = 10)
# DimPlot(seurat_integrated, reduction = "umap", group.by = "seurat_clusters")
# dev.off()

# Check QC metrics
FeaturePlot(seurat_integrated, features = c("nFeature_RNA", "nCount_RNA", "percent_mt", "percent_rb"))
# pdf(paste(workdir, "/UMAPs/integrated_umap_QC.pdf", sep = ""), width = 10, height = 10)
# FeaturePlot(seurat_integrated, features = c("nFeature_RNA", "nCount_RNA", "percent_mt", "percent_rb"))
# dev.off()

```

## DE genes per cluster

* Two main functions are used for the differential expression among groups:

* `FindMarkers()` finds markers between two different identity groups - both need to be specified. This is useful for comparing the differences between two specific groups.

* `FindAllMarkers()` is the one we use for this step. It finds markers differentially expressed in each identity group by comparing it to all of the others. Note that markers may bleed over between closely-related groups - they are not forced to be specific to only one group.

* List of genes expressed in the different clusters can be downloaded from here
[[https://imperiallondon-my.sharepoint.com/:f:/g/personal/jurtasun_ic_ac_uk/EgfDne6E6SxAkA6jfSHexYgBDH4uNYJo7SBASjicts5vJw?e=XJv0ys]]

```{r DEgenes_int1, cache = T, echo = T, eval = T, warnings = F, messages = F, fig.height = 8, fig.width = 12, results = "asis"}

# Run FindAllMarkers DE test
# int_markers <- FindAllMarkers(seurat_integrated, only.pos = TRUE, min.pct = 0.25, assay = "RNA", logfc.threshold = 0.25)
# write.csv(int_markers, file = "Cell_Markers/integrated_markers.csv", row.names = F)

# Look for specific genes
# grep("Actb", rownames(seurat_integrated@assays$RNA@scale.data))
# grep("Xist", rownames(seurat_integrated@assays$RNA@scale.data))
FeaturePlot(seurat_integrated, features = c("Actb", "Xist", "Kit", "Myc"))

# # Check number of genes used for the UMAP
# conserved_markers <- FindConservedMarkers(seurat_integrated,
#                                           assay = "RNA",
#                                           ident.1 = "1",
#                                           grouping.var = "orig.ident",
#                                           min.cells.group = 1)

```

# Cluster annotation with ScType {.tabset}

* Populations of interest

    + CLP (cell type)
    + GMP (cell type)
    + CMP (cell type)
    + MEP (cell type)
    + B cell lineage (cell lineage)
    + T cell lineage (cell lineage)
    + Macrophage lineage (cell lineage)
    + Granulocytes (eosinophils, basophils and neutrophil lineage)
    + Dendritic (cell lineage)

* ScType workflow consists of the following steps:

* Input data quality control

    + Cell - based quality control (e.g. removing cells with unexpectedly high counts)
    + Gene - based quality control (i.e. subsetting highly-variable genes)

* Data normalization and scaling. Default normalization is done using SCTransform, but such as log-normalization are available

* Data clustering based on highly variable genes (default is Louvain clustering based on a shared nearest neighbor graph, but many other options are available)

* Reference:

      + Ianevski et al. (2022). Fully-automated and ultra-fast cell-type identification. Nature Communications 13:1246

```{r sctype1, cache = T, echo = F, eval = T, warnings = F, messages = F, fig.height = 8, fig.width = 12, results = "asis"}

# Load Seurat object
load("Seurat_Object/WT_processed.RData")
load("Seurat_Object/MT_processed.RData")
load("Seurat_Object/seurat_integrated.RData")

# # Check dimensions of WT, MT, integrated
# dim(WT_processed[["RNA"]]@scale.data)
# dim(MT_processed[["RNA"]]@scale.data)
# dim(seurat_integrated@assays$integrated@data)

# Load libraries and functions
lapply(c("dplyr","Seurat","HGNChelper"), library, character.only = T)

# Import gene sets and sctype score
suppressPackageStartupMessages(source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R"))
suppressPackageStartupMessages(source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R"))

# DB file
# db_ = "https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_full.xlsx";
# https://www.ensembl.org/index.html
# Export homolog genes from mouse to human GeneSymbol
# Extract last column
# > cat multipotent_progenitors_mart_export.txt | cut -f5 | sort -u | paste -d, -s -
# > cat restricted_progenitors_mart_export.txt | cut -f5 | sort -u | paste -d, -s -
db_ = paste0(workdir, "/../Project_description/ScTypeDB_custom.xlsx");
tissue = "Immune system" # e.g. Immune system,Pancreas,Liver,Eye,Kidney,Brain,Lung,Adrenal,Heart,Intestine,Muscle,Placenta,Spleen,Stomach,Thymus

# Prepare gene sets
gs_list = gene_sets_prepare(db_, tissue)

```

* Figures in high resolution can be found here
[[https://imperiallondon-my.sharepoint.com/:f:/g/personal/jurtasun_ic_ac_uk/EgfDne6E6SxAkA6jfSHexYgBDH4uNYJo7SBASjicts5vJw?e=XJv0ys]]

## Wild-type

```{r sctype_wt1, cache = T, echo = T, eval = T, warnings = F, messages = F, fig.height = 8, fig.width = 12, results = "asis"}

# Get cell-type by cell matrix
es.max = sctype_score(scRNAseqData = WT_processed[["RNA"]]@scale.data, scaled = TRUE, gs = gs_list$gs_positive, gs2 = gs_list$gs_negative)

# Merge by cluster
cL_resutls = do.call("rbind", lapply(unique(WT_processed@meta.data$seurat_clusters), function(cl) {
      es.max.cl = sort(rowSums(es.max[ , rownames(WT_processed@meta.data[WT_processed@meta.data$seurat_clusters == cl, ])]), decreasing = !0)
      head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl, ncells = sum(WT_processed@meta.data$seurat_clusters == cl)), 10)
}))
sctype_scores = cL_resutls %>% group_by(cluster) %>% top_n(n = 1, wt = scores)

# Set low-confident (low ScType score) clusters to "unknown"
sctype_scores$type[as.numeric(as.character(sctype_scores$scores)) < sctype_scores$ncells/4] = "Unknown"

# Overlay the identified cell types on UMAP plot
WT_processed@meta.data$customclassif = ""
for(j in unique(sctype_scores$cluster)) {
      cl_type = sctype_scores[sctype_scores$cluster == j, ];
      WT_processed@meta.data$customclassif[WT_processed@meta.data$seurat_clusters == j] = as.character(cl_type$type[1])
}

DimPlot(WT_processed, reduction = "umap", label = TRUE, repel = TRUE, group.by = "customclassif")
# pdf(paste(workdir, "/UMAPs/wt_umap_annotated_custom.pdf", sep = ""), width = 15, height = 10)
# DimPlot(WT_processed, reduction = "umap", label = TRUE, repel = TRUE, group.by = 'customclassif')
# dev.off()

```

## Mutant

```{r sctype_mt1, cache = T, echo = T, eval = T, warnings = F, messages = F, fig.height = 8, fig.width = 12, results = "asis"}

# Get cell-type by cell matrix
es.max = sctype_score(scRNAseqData = MT_processed[["RNA"]]@scale.data, scaled = TRUE, gs = gs_list$gs_positive, gs2 = gs_list$gs_negative)

# Merge by cluster
cL_resutls = do.call("rbind", lapply(unique(MT_processed@meta.data$seurat_clusters), function(cl) {
      es.max.cl = sort(rowSums(es.max[ , rownames(MT_processed@meta.data[MT_processed@meta.data$seurat_clusters == cl, ])]), decreasing = !0)
      head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl, ncells = sum(MT_processed@meta.data$seurat_clusters == cl)), 10)
}))
sctype_scores = cL_resutls %>% group_by(cluster) %>% top_n(n = 1, wt = scores)

# Set low-confident (low ScType score) clusters to "unknown"
sctype_scores$type[as.numeric(as.character(sctype_scores$scores)) < sctype_scores$ncells/4] = "Unknown"

# Overlay the identified cell types on UMAP plot
MT_processed@meta.data$customclassif = ""
for(j in unique(sctype_scores$cluster)) {
      cl_type = sctype_scores[sctype_scores$cluster == j, ];
      MT_processed@meta.data$customclassif[MT_processed@meta.data$seurat_clusters == j] = as.character(cl_type$type[1])
}

DimPlot(MT_processed, reduction = "umap", label = TRUE, repel = TRUE, group.by = "customclassif")
# pdf(paste(workdir, "/UMAPs/mt_umap_annotated_custom.pdf", sep = ""), width = 15, height = 10)
# DimPlot(MT_processed, reduction = "umap", label = TRUE, repel = TRUE, group.by = 'customclassif')
# dev.off()

```

## Integrated

```{r sctype_int1, cache = T, echo = T, eval = T, warnings = F, messages = F, fig.height = 8, fig.width = 12, results = "asis"}

# Get cell-type by cell matrix
es.max = sctype_score(scRNAseqData = as.matrix(seurat_integrated@assays$integrated@data), scaled = TRUE,
                      gs = gs_list$gs_positive, gs2 = gs_list$gs_negative)

# Merge by cluster
cL_resutls = do.call("rbind", lapply(unique(seurat_integrated@meta.data$seurat_clusters), function(cl) {
      es.max.cl = sort(rowSums(es.max[ , rownames(seurat_integrated@meta.data[seurat_integrated@meta.data$seurat_clusters == cl, ])]), decreasing = !0)
      head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl, ncells = sum(seurat_integrated@meta.data$seurat_clusters == cl)), 10)
}))
sctype_scores = cL_resutls %>% group_by(cluster) %>% top_n(n = 1, wt = scores)

# Set low-confident (low ScType score) clusters to "unknown"
sctype_scores$type[as.numeric(as.character(sctype_scores$scores)) < sctype_scores$ncells/4] = "Unknown"

# Overlay the identified cell types on UMAP plot
seurat_integrated@meta.data$customclassif = ""
for(j in unique(sctype_scores$cluster)) {
      cl_type = sctype_scores[sctype_scores$cluster == j, ];
      seurat_integrated@meta.data$customclassif[seurat_integrated@meta.data$seurat_clusters == j] = as.character(cl_type$type[1])
}

DimPlot(seurat_integrated, reduction = "umap", label = TRUE, repel = TRUE, group.by = 'customclassif')
# pdf(paste(workdir, "/UMAPs/integrated_umap_annotated_custom.pdf", sep = ""), width = 15, height = 10)
# DimPlot(seurat_integrated, reduction = "umap", label = TRUE, repel = TRUE, group.by = 'customclassif')
# dev.off()

```

* Display multipotent and restricted progenitors as labeled by ScType

```{r sctype_prog, cache = T, echo = T, eval = T, warnings = F, messages = F, fig.height = 8, fig.width = 12, results = "asis"}

# Count multipotent and restricted progenitors
seurat_integrated@meta.data$mp_progenitor_score <- es.max["Progenitors - multipotent", ]
seurat_integrated@meta.data$rs_progenitor_score <- es.max["Progenitors - restricted", ]
seurat_integrated@meta.data$is_mp_progenitor <- es.max["Progenitors - multipotent", ] == apply(es.max, 2, max)
seurat_integrated@meta.data$is_rs_progenitor <- es.max["Progenitors - restricted", ] == apply(es.max, 2, max)
seurat_integrated@meta.data$is_all_progenitor <- ifelse(
      seurat_integrated@meta.data$is_mp_progenitor == "TRUE" | seurat_integrated@meta.data$is_rs_progenitor == "TRUE", "TRUE", "FALSE")
DimPlot(seurat_integrated, reduction = "umap", group.by = "is_mp_progenitor")

# ftable(seurat_integrated@meta.data$is_mp_progenitor)[[2]] +
# ftable(seurat_integrated@meta.data$is_rs_progenitor)[[2]] ==
# ftable(seurat_integrated@meta.data$is_all_progenitor)[[2]]

DimPlot(seurat_integrated, reduction = "umap", group.by = "is_mp_progenitor")
# pdf(paste(workdir, "/UMAPs/multipotent_progenitors_custom.pdf", sep = ""), width = 10, height = 10)
# DimPlot(seurat_integrated, reduction = "umap", group.by = "is_mp_progenitor")
# dev.off()
DimPlot(seurat_integrated, reduction = "umap", group.by = "is_rs_progenitor")
# pdf(paste(workdir, "/UMAPs/restricted_progenitors_custom.pdf", sep = ""), width = 10, height = 10)
# DimPlot(seurat_integrated, reduction = "umap", group.by = "is_rs_progenitor")
# dev.off()
DimPlot(seurat_integrated, reduction = "umap", group.by = "is_all_progenitor")
# pdf(paste(workdir, "/UMAPs/restricted_progenitors_custom.pdf", sep = ""), width = 10, height = 10)
# DimPlot(seurat_integrated, reduction = "umap", group.by = "is_all_progenitor")
# dev.off()

# Count progenitor-like cells
seurat_integrated_wt <- seurat_integrated@meta.data[seurat_integrated@meta.data$orig.ident == "WT", ]
seurat_integrated_mt <- seurat_integrated@meta.data[seurat_integrated@meta.data$orig.ident == "MT", ]
# dim(seurat_integrated_wt)[1] == ftable(seurat_integrated@meta.data$orig.ident)[2]
# dim(seurat_integrated_mt)[1] == ftable(seurat_integrated@meta.data$orig.ident)[1]
ftable(seurat_integrated@meta.data$orig.ident)
ftable(seurat_integrated_wt$is_mp_progenitor)
ftable(seurat_integrated_wt$is_rs_progenitor)
ftable(seurat_integrated_mt$is_mp_progenitor)
ftable(seurat_integrated_mt$is_rs_progenitor)
# write.table(paste("\nMultipotent progenitors: ", ftable(seurat_integrated_wt$is_mp_progenitor)[2], " cells\n",
#                   "\nRestricted progenitors: ", ftable(seurat_integrated_wt$is_rs_progenitor)[2], " cells\n"),
#                   file = paste(workdir, "/../QC_10X/summary_wt.txt", sep = ""), append = TRUE)
# write.table(paste("\nMultipotent progenitors: ", ftable(seurat_integrated_mt$is_mp_progenitor)[2], " cells\n",
#                   "\nRestricted progenitors: ", ftable(seurat_integrated_mt$is_rs_progenitor)[2], " cells\n"),
#                   file = paste(workdir, "/../QC_10X/summary_mt.txt", sep = ""), append = TRUE)

```

# Differential expression analysis

* Perform differential expression in the progenitors cluster, comparing expression level between WT and MT.

* DE results can be downloaded from here
[[https://imperiallondon-my.sharepoint.com/:f:/g/personal/jurtasun_ic_ac_uk/EiCPqhlsWZlFsAqKNv5PEwUB7NKE6dpHbJ6v6xNNjnghSA?e=W6VTWT]

```{r DE1, cache = T, echo = T, eval = T, warnings = F, messages = F, fig.height = 8, fig.width = 12, results = "asis"}

# Cluster of interest
clusters <- c("all progenitors", "multipotent progenitors", "restricted progenitors",
              "B_cells", "T_cells", "basophils", "dendritic", "eosinophils", "erythrocytes",
              "macrophages", "mast_cells", "megakaryocytes", "neutrophils", "nk_cells")

# Add pseudocount
seurat_integrated2 <- seurat_integrated
seurat_integrated2[["RNA"]]@counts <- as.matrix(seurat_integrated2[["RNA"]]@counts) + 1

# for (i in 1:3) {
# 
#       cluster_i <- clusters[[i]]
#       cat("\n", cluster_i)
# 
#       # Set identity based on target cluster
#       # Idents(seurat_integrated2) <- seurat_integrated2@meta.data$is_mp_progenitor
#       # Idents(seurat_integrated2) <- seurat_integrated2@meta.data$is_rs_progenitor
#       Idents(seurat_integrated2) <- seurat_integrated2@meta.data$is_all_progenitor
# 
#       # cat("\n", ftable(seurat_integrated2@meta.data$is_mp_progenitor))
#       # cat("\n", ftable(seurat_integrated2@meta.data$is_rs_progenitor))
#       # cat("\n", ftable(seurat_integrated2@meta.data$is_all_progenitor))
#       # cat("\n", ftable(Idents(seurat_integrated2)))
#       DefaultAssay(seurat_integrated2) <- "RNA"
#       res <- FindMarkers(
#             seurat_integrated2,
#             ident.1 = "WT",
#             ident.2 = "MT",
#             verbose = TRUE,
#             group.by = "orig.ident", # Name of the metadata column with the above WT / KO annotations
#             subset.ident = TRUE, # Either be the cluster ID or the ID within a custom metadata column,
#             test.use = "DESeq2",
#             logfc.threshold = log2(2))
# 
#       # Add gene name and store output
#       res_sym <- res
#       res_sym$gene_name <- rownames(res_sym)
#       res_sym <- res_sym[, c("gene_name", "pct.1", "pct.2", "p_val", "p_val_adj", "avg_log2FC")]
#       # write.csv(res_sym, file = paste0(workdir, "/DE_Analysis/DE_multipotent_progenitors_MT_vs_WT_DESeq2_pseudocount.csv"), row.names = F)
#       # write.csv(res_sym, file = paste0(workdir, "/DE_Analysis/DE_restricted_progenitors_MT_vs_WT_DESeq2_pseudocount.csv"), row.names = F)
#       write.csv(res_sym, file = paste0(workdir, "/DE_Analysis/DE_progenitors_MT_vs_WT_DESeq2.csv"), row.names = F)
# 
# }

# # Population abundance
# cells_total <- dim(seurat_integrated)[2]
# cells_total_WT <- ftable(seurat_integrated$orig.ident)[1]
# cells_total_MT <- ftable(seurat_integrated$orig.ident)[2]
# # cells_total_WT + cells_total_MT == cells_total
# cells_progenitor <- ftable(seurat_integrated$is_all_progenitor)[2]
# cells_progenitor_WT <- dim(seurat_integrated@meta.data[seurat_integrated@meta.data$is_all_progenitor == TRUE &
#                                                              seurat_integrated@meta.data$orig.ident == "WT", ])[1]
# cells_progenitor_MT <- dim(seurat_integrated@meta.data[seurat_integrated@meta.data$is_all_progenitor == TRUE &
#                                                              seurat_integrated@meta.data$orig.ident == "MT", ])[1]
# # cells_progenitor_WT + cells_progenitor_MT == cells_progenitor
#
# # Print relative abundances
# cat("\nTotal number of cells: ", cells_total)
# cat("\nCells in progenitor cluster: ", cells_progenitor,
#     "\n\nRelative abundance: ", cells_progenitor / cells_total * 100, "%")
#
# cat("\nCells in progenitor cluster - coming from WT: ", cells_progenitor_WT,
#     # "\n\nRelative abundance: ", cells_progenitor_WT / cells_total * 100, "% of the total cells",
#     "\n\nRelative abundance: ", cells_progenitor_WT / cells_progenitor * 100, "% of the progenitor cluster")
#
# cat("\nCells in progenitor cluster - coming from MT: ", cells_progenitor_MT,
#     # "\n\nRelative abundance: ", cells_progenitor_MT / cells_total * 100, "% of the total cells",
#     "\n\nRelative abundance: ", cells_progenitor_MT / cells_progenitor * 100, "% of the progenitor cluster")

# # Add information to DE results
# res <- read.csv(paste0(workdir, "/DE_Analysis/DE_progenitors_MT_vs_WT_DESeq2_pseudocount.csv"))
# gene_vf <- VariableFeatures(seurat_integrated)
# res$is_vf <- ifelse(res$gene_name %in% gene_vf, "TRUE", "FALSE")
# all(sort(gene_vf) == sort(res[res$is_vf == "TRUE", ]$gene_name))
# dim(seurat_integrated@assays$RNA@counts)
# ftable(seurat_integrated@meta.data$orig.ident)

# # Add information to DE results
# res <- read.csv(paste0(workdir, "/DE_Analysis/DE_progenitors_MT_vs_WT_DESeq2_filtered.csv"))
# gene_vf <- VariableFeatures(seurat_integrated)
# res$is_vf <- ifelse(res$gene_name %in% gene_vf, "TRUE", "FALSE")
# write.csv(res, file = paste0(workdir, "/DE_Analysis/DE_progenitors_MT_vs_WT_DESeq2_filtered2.csv"), row.names = F)
# all(sort(gene_vf) == sort(res[res$is_vf == "TRUE", ]$gene_name))
# dim(seurat_integrated@assays$RNA@counts)
# ftable(seurat_integrated@meta.data$orig.ident)

```

# Pathway analysis

* Perform pathway analysis on the DE genes of the progenitor cluster, comparing expression level between WT and MT.

* Output files and figures in high resolution can be downloaded from here
[[https://imperiallondon-my.sharepoint.com/:f:/g/personal/jurtasun_ic_ac_uk/Eg-Wxf1PhZ1GsFtbYwZq5pQBtKnM1dJucngPXdfNPAO-ZQ?e=a6cYkK]]

```{r go1, cache = T, echo = T, eval = T, warnings = F, messages = F, fig.height = 8, fig.width = 12, results = "asis"}

# # Get gene annotation from biomart
# mart <- useMart("ensembl", dataset = "mmusculus_gene_ensembl", host = "https://may2015.archive.ensembl.org")
# # Check the annotation version
# datasets <- listDatasets(mart)
# datasets[which(datasets[, 1] == "mmusculus_gene_ensembl"), ]
# list_attributes <- listAttributes(mart)
# # Get gene annotation from biomart
# bm_chr <- getBM(attributes = c("ensembl_gene_id", "external_gene_name", "chromosome_name"),
#                 filters = "external_gene_name", values = res$gene_name,
#                 mart = mart)
# save(bm_chr, file = "bm_chr.RData")
load("bm_chr.RData")

# Iterate over clusters
for (i in 1:2) {

      cluster_i <- clusters[[i]]
      cat("\n", cluster_i)

      # Read DE results      
      res <- read.csv(paste0(workdir, "/DE_Analysis/DE_progenitors_MT_vs_WT_DESeq2_filtered.csv"))

      # P value cut-off
      go_alpha = 0.05

      # Add entrez id for KEGG pathways
      res_sym <- merge(bm_chr[, c(1, 2)], res, by.x = "external_gene_name", by.y = "gene_name", all.y = TRUE)
      ensembl_ids <- res_sym$ensembl_gene_id
      entrez_ids <- mapIds(org.Mm.eg.db, keys = ensembl_ids, keytype = "ENSEMBL", column = "ENTREZID")
      entrez_ids <- entrez_ids[names(entrez_ids) %in% res_sym$ensembl_gene_id]
      # length(entrez_ids) == dim(res_sym)[1]
      # all(na.omit(names(entrez_ids) == (res_sym$ensembl_gene_id)))
      res_sym$entrez_id <- entrez_ids
      res_sym <- na.omit(res_sym[is.finite(res_sym$avg_log2FC), ])

      # Get GO terms using Ensemble IDs
      go_up <- clusterProfiler::enrichGO(
            gene = dplyr::filter(res_sym, p_val_adj < 0.05 & avg_log2FC > 0) %>% dplyr::pull(ensembl_gene_id),
            OrgDb = org.Mm.eg.db, keyType = "ENSEMBL", ont = "BP",
            pAdjustMethod = "BH", pvalueCutoff = go_alpha, qvalueCutoff = go_alpha, readable = T)
      dplyr::filter(go_up, p.adjust < go_alpha, qvalue < go_alpha)
      go_up_order <- go_up@result[order(go_up@result$Count, decreasing = TRUE), ]

      # Get set of Ensemble IDs to query
      go_down <- clusterProfiler::enrichGO(
            gene <- dplyr::filter(res_sym, p_val_adj < 0.05 & avg_log2FC < 0) %>% dplyr::pull(ensembl_gene_id),
            OrgDb = org.Mm.eg.db, keyType = "ENSEMBL", ont = "BP",
            pAdjustMethod = "BH", pvalueCutoff = go_alpha, qvalueCutoff = go_alpha, readable = T)
      dplyr::filter(go_down, p.adjust < go_alpha, qvalue < go_alpha)
      go_down_order <- go_down@result[order(go_down@result$Count, decreasing = TRUE), ]

      # # Write out GO output
      # write.csv(go_up_order, file = paste0(workdir, "/GO_Analysis/GO_progenitors_MT_vs_WT_go_up_DESeq2_filtered.csv"), row.names = F)
      # write.csv(go_down_order, file = paste0(workdir, "/GO_Analysis/GO_progenitors_MT_vs_WT_go_down_DESeq2_filtered.csv"), row.names = F)

      # Save PDF file
      clusterProfiler::dotplot(go_up, showCategory = 15) + ggplot2::theme(axis.text.y = element_text(size = 8))
      # pdf(paste(workdir, "/GO_Analysis/GO_progenitors_MT_vs_WT_go_up_DESeq2_filtered.pdf", sep = ""), width = 10, height = 10)
      # clusterProfiler::dotplot(go_up, showCategory = 15) + ggplot2::theme(axis.text.y = element_text(size = 8))
      # dev.off()
      clusterProfiler::dotplot(go_down, showCategory = 15) + ggplot2::theme(axis.text.y = element_text(size = 8))
      # pdf(paste(workdir, "/GO_Analysis/GO_progenitors_MT_vs_WT_go_down_DESeq2_filtered.pdf", sep = ""), width = 10, height = 10)
      # clusterProfiler::dotplot(go_down, showCategory = 15) +ggplot2::theme(axis.text.y = element_text(size = 8))
      # dev.off()

      # # Get KEGG terms using Ensemble IDs to query
      # kegg_up <- clusterProfiler::enrichKEGG(
      #       gene = na.omit(as.character(res_sym[res_sym$avg_log2FC > 0, ]$entrez_id)),
      #       organism = "mmu", keyType = "ncbi-geneid",
      #       pAdjustMethod = "BH", qvalueCutoff = go_alpha)
      #  kegg_down <- clusterProfiler::enrichKEGG(
      #       gene = na.omit(as.character(res_sym[res_sym$avg_log2FC < 0, ]$entrez_id)),
      #       organism = "mmu", keyType = "ncbi-geneid",
      #       pAdjustMethod = "BH", qvalueCutoff = go_alpha)
      # # Write out KEGG output
      # if (i == 1) {
      #       write.csv(kegg_up, file = paste0(workdir, "/KEGG_Analysis/KEGG_progenitors_MT_vs_WT_up.csv"), row.names = F)
      #       write.csv(kegg_down, file = paste0(workdir, "/KEGG_Analysis/KEGG_progenitors_MT_vs_WT_down.csv"), row.names = F)
      # } else {
      #       write.csv(kegg_up, file = paste0(workdir, "/KEGG_Analysis/KEGG_", cluster_i, "_MT_vs_WT_up.csv"), row.names = F)
      #       write.csv(kegg_down, file = paste0(workdir, "/KEGG_Analysis/KEGG_", cluster_i, "_MT_vs_WT_down.csv"), row.names = F)
      # }
      # # # Save PDF file
      # kegg_plot_up <- clusterProfiler::dotplot(kegg_up, showCategory = 15) + ggplot2::theme(axis.text.y = element_text(size = 8))
      # kegg_plot_down <- clusterProfiler::dotplot(kegg_down, showCategory = 15) + ggplot2::theme(axis.text.y = element_text(size = 8))
      # ggsave(paste0(workdir, "/KEGG_Analysis/KEGG_", cluster_i, "_MT_vs_WT_up.pdf", sep = ""),
      #        plot = kegg_plot_up, width = 10, height = 10, dpi = 500)
      # ggsave(paste0(workdir, "/KEGG_Analysis/KEGG_", cluster_i, "_MT_vs_WT_down.pdf", sep = ""),
      #        plot = kegg_plot_down, width = 10, height = 10, dpi = 500)

}

```

# GSEA analysis

* Perform enrichment analysis on the ranked DE lists

* Output files and figures in high resolution can be downloaded from here
[[https://imperiallondon-my.sharepoint.com/:f:/g/personal/jurtasun_ic_ac_uk/EsalHh8Yg61OggDv5NnfXXYBE0qIRw0Q5qj0qvBJrZrNHQ?e=NiSZb1]]

```{r gsea1, cache = T, echo = T, eval = T, warnings = F, messages = F, fig.height = 8, fig.width = 12, results = "asis"}

# https://yulab-smu.top/biomedical-knowledge-mining-book/universal-api.html#msigdb-analysis
# Get hallmark gene list
hallmarks <- msigdbr(species = "Mus musculus", category = "H")
hallmarks <- dplyr::select(hallmarks, gs_name, gene_symbol)

# Iterate over clusters
for (i in 1:2) {

      cluster_i <- clusters[[i]]
      cat("\n", cluster_i)
      go_alpha = 0.05

      # Read DE results      
      res <- read.csv(paste0(workdir, "/DE_Analysis/DE_progenitors_MT_vs_WT_DESeq2_filtered.csv"))
      res_sym <- merge(bm_chr[, c(1, 2)], res, by.x = "external_gene_name", by.y = "gene_name", all.y = TRUE)
      res_sym <- na.omit(res_sym[order(-res_sym$avg_log2FC), ])
      res_sym <- res_sym[is.finite(res_sym$avg_log2FC), ]
      gene_list <- res_sym[res_sym$p_val_adj > 0.05, ]$external_gene_name

      # Get GSEA terms using Ensemble IDs
      gsea <- clusterProfiler::enricher(
            gene = gene_list,
            TERM2GENE = hallmarks)
      dplyr::filter(gsea, p.adjust < go_alpha, qvalue < go_alpha)
      gsea_order <- gsea@result[order(gsea@result$Count, decreasing = TRUE), ]
      # # Write out GO output
      # write.csv(gsea, file = paste0(workdir, "/GSEA_Analysis/GSEA_progenitors_MT_vs_WT_DESeq2_filtered.csv"), row.names = F)

      # # Save PDF file
      gsea_bar <- barplot(gsea, showCategory = 15) + ggplot2::theme(axis.text.y = element_text(size = 8))
      # ggsave(paste0(workdir, "/GSEA_Analysis/GSEA_progenitors_MT_vs_WT_DESeq2_filtered.pdf", sep = ""),
      #        plot = gsea_bar, width = 10, height = 10, dpi = 500)
      
      # Add entrez id and order for GSEA
      res_sym <- merge(bm_chr[, c(1, 2)], res, by.x = "external_gene_name", by.y = "gene_name", all.y = TRUE)
      ensembl_ids <- res_sym$ensembl_gene_id
      entrez_ids <- mapIds(org.Mm.eg.db, keys = ensembl_ids, keytype = "ENSEMBL", column = "ENTREZID")
      entrez_ids <- entrez_ids[names(entrez_ids) %in% res_sym$ensembl_gene_id]
      # length(entrez_ids) == dim(res_sym)[1]
      # all(na.omit(names(entrez_ids) == (res_sym$ensembl_gene_id)))
      res_sym$entrez_id <- as.character(entrez_ids)
      res_sym <- res_sym %>% drop_na(entrez_id)
      res_sym <- na.omit(res_sym[is.finite(res_sym$avg_log2FC), ])
      # res_sym_ordered <- res_sym[order(res_sym$avg_log2FC, decreasing = TRUE), ]
      res_sym_ordered <- res_sym[order(res_sym$p_val_adj, decreasing = TRUE), ]

      # Get GSEA terms using Entrez IDs
      gene_list2 <- res_sym_ordered[, "p_val_adj"]
      names(gene_list2) <- res_sym_ordered[, "entrez_id"]
      gsea2 <- gseDO(gene_list2, by = "DOSE", nPerm = 10, pvalueCutoff = 1)
      # gsea2 <- gseDO(gene_list2, pvalueCutoff = 1)

      # # Save PDF figure
      # gsea2_plot <- enrichplot::gseaplot(gsea2, geneSetID = 1, title = gsea$Description[2])
      # ggsave(paste0(workdir, "/GSEA_Analysis/GSEA_progenitors_MT_vs_WT_DESeq2_filtered_enrich_plot3.pdf", sep = ""),
      #        plot = gsea2_plot, width = 10, height = 10, dpi = 500)
      

}

```

# SessionInfo

```{r, cache = T, echo = T, eval = T, warnings = F, messages = F, fig.height = 12, fig.width = 10}

sessionInfo()

```

